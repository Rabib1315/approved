---
alwaysApply: true
---

# Prompt Manager Development Rules

## Tech Stack
- **Frontend**: Next.js 15, React 19, TypeScript, Tailwind CSS, shadcn/ui, Framer Motion
- **Backend**: Drizzle ORM, PostgreSQL, Supabase
- **Auth**: Clerk

## File Structure
```
actions/              # Server actions (prompts-actions.ts, auth-actions.ts)
app/                  # Next.js app directory
├── globals.css       # Tailwind imports
├── layout.tsx        # Root layout with ClerkProvider
├── page.tsx          # Landing page
├── (auth)/sign-in/   # Auth pages
└── prompts/          # Feature pages
    ├── page.tsx      # Main prompts page
    └── components/   # Feature components
components/
├── ui/              # shadcn/ui components
└── header.tsx       # Shared components
db/
├── index.ts         # Database connection
├── schema/          # Drizzle schemas (*-schema.ts)
└── migrations/      # Auto-generated migrations
lib/                 # Utilities (utils.ts, dev-delay.ts)
middleware.ts        # Clerk auth middleware
```

## Naming Conventions
- Use **kebab-case** for all files and folders
- Server Actions: `*-actions.ts`
- Database Schemas: `*-schema.ts`
- Export client components as: `export const MyComponent`
- Export server components as: `export default function MyPage`

## Server Actions Pattern
```typescript
"use server"

import { db } from "@/db"
import { prompts } from "@/db/schema/prompts-schema"
import { requireUserId } from "./auth-actions"
import { eq, desc, and } from "drizzle-orm"

export async function getPrompts() {
  try {
    const userId = await requireUserId()
    const allPrompts = await db
      .select()
      .from(prompts)
      .where(eq(prompts.user_id, userId))
      .orderBy(desc(prompts.created_at))
    return allPrompts
  } catch (error) {
    console.error("Error fetching prompts:", error)
    throw new Error("Failed to fetch prompts")
  }
}
```

## Database Schema Pattern
```typescript
// db/schema/prompts-schema.ts
import { pgTable, serial, text, timestamp } from "drizzle-orm/pg-core"

export const prompts = pgTable("prompts", {
  id: serial("id").primaryKey(),
  user_id: text("user_id").notNull(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  content: text("content").notNull(),
  created_at: timestamp("created_at").defaultNow().notNull(),
  updated_at: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date())
})

export type InsertPrompt = typeof prompts.$inferInsert
export type SelectPrompt = typeof prompts.$inferSelect
```

## Client Component Pattern
```typescript
"use client"

import { useState } from "react"
import { motion } from "framer-motion"
import { createPrompt } from "@/actions/prompts-actions"

export const PromptsGrid = ({ initialPrompts }: PromptsGridProps) => {
  const [prompts, setPrompts] = useState(initialPrompts)

  const handleCreate = async (formData: FormData) => {
    try {
      const newPrompt = await createPrompt({
        name: formData.get('name') as string,
        description: formData.get('description') as string,
        content: formData.get('content') as string
      })
      setPrompts(prev => [newPrompt, ...prev])
    } catch (error) {
      console.error('Failed to create prompt:', error)
    }
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
    >
      {prompts.map((prompt, index) => (
        <motion.div
          key={prompt.id}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: index * 0.1 }}
        >
          <PromptCard prompt={prompt} />
        </motion.div>
      ))}
    </motion.div>
  )
}
```

## Server Page Pattern
```typescript
// Always fetch data in server components and pass to client components
import { getPrompts } from "@/actions/prompts-actions"
import { PromptsGrid } from "./components/prompts-grid"

export default async function PromptsPage() {
  return (
    <>
      <Header />
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-8">My Prompts</h1>
        <Suspense fallback={<LoadingGrid />}>
          <PromptsContent />
        </Suspense>
      </div>
    </>
  )
}

async function PromptsContent() {
  const prompts = await getPrompts()
  return <PromptsGrid initialPrompts={prompts} />
}
```

## Auth Setup
```typescript
// middleware.ts
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server"

const isPublicRoute = createRouteMatcher(["/", "/sign-in(.*)"])

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect()
  }
})

// actions/auth-actions.ts
import { auth } from "@clerk/nextjs/server"

export async function requireUserId(): Promise<string> {
  const { userId } = await auth()
  if (!userId) throw new Error("Authentication required")
  return userId
}
```

## Database Commands
```bash
npm run db:generate  # Generate migrations from schema changes
npm run db:migrate   # Apply migrations
npm run db:seed      # Seed with sample data
```

## Key Rules
1. **Always** fetch data in server components, pass to client components
2. **Always** use `requireUserId()` in server actions for auth
3. **Always** verify user ownership: `and(eq(table.id, id), eq(table.user_id, userId))`
4. **Always** use proper error handling in server actions
5. Use Framer Motion for animations
6. Use shadcn/ui components
7. Export client components as named exports
8. Use kebab-case for all file names